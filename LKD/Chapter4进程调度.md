## 进程调度

调度程序负责决定将哪个进程投入运行，何时运行以及运行多长时间。调度程序可以看做在可运行态进程之间分配有限的处理器时间资源的内核子系统。为遵循最大限度利用处理器时间的原则，只要有可以执行的进程，那么就总会有进程在执行。

### 策略

进程可以分为I/O消耗型和处理器消耗型。

进程优先级：Linux采用两种不同的优先级范围。第一种是nice值，范围是-20到19，默认为0，nice值越小优先级越高，在linux中nice值代表时间片的**比例**。第二种是实时优先级，其值是可配置的，默认情况下它的范围是0到99，越高的实时优先级数值意味着进程优先级越高。

时间片是一个数值，它表明进程在被抢占前所能持续运行的时间。在linux的CFS调度器并没有直接分配时间片到进程，它是将处理器的使用比例分配给进程。

### Linux调度算法

#### 调度器类

Linux调度器是以模块方式提供的，这样做的目的是允许不同类型的进程可以有针对性的选择调度算法。这种模块化结构被称为调度器类，它允许把多种不同的可动态添加的调度算法并存，调度属于自己范畴的程序。每个调度器都有一个优先级，它会按照优先级遍历调度类，拥有一个可执行进程的 最高优先级的调度器类胜出，去选择下面要执行的那一个程序。

#### 公平调度

CFS基于一个简单的理念：进程调度的效果应如同系统具备一个理想中的完美多任务处理器。在这种系统中，每个进程获得1/n的处理器时间—n是指可运行进程的数量。

CFS的做法是允许每个进程运行一段时间、循环轮转、选择运行时间最少的进程作为下一个进程。任何进程所获得的处理器时间是由他自己和其他所有可运行进程nice值的**相对差值**决定的。

理想状态下每个进程都能获得相同的时间片，并且同时运行在CPU上，但实际上一个CPU同一时刻运行的进程只能有一个。也就是说，当一个进程占用CPU时，其他进程就必须等待。CFS为了实现公平，必须惩罚当前正在运行的进程，以使那些正在等待的进程下次被调度。



进程的运行时间计算公式为: 

​	分配给进程的运行时间 = 调度周期 * 进程权重 / 所有进程权重之和 

公平是体现在另外一个量上面，叫做virtual runtime(vruntime)，它记录着进程已经运行的时间， 但是并不是直接记录，而是要根据进程的权重将运行时间放大或者缩小一个比例。

从实际运行时间到vruntime的换算公式 为：

​		vruntime = 实际运行时间 * 1024 / 进程权重 

公式中的1024，实际上它等于nice为0的进程的权重，代码中是NICE_0_LOAD。也就是说，所有进程都以nice为0的进程的权重1024作为基准，计算自己的vruntime增加速度。

我们把公式2中的实际运行时间用公式1来替换，可以得到这么一个结果：

​	 vruntime = (调度周期 * 进程权重 / 所有进程总权重) * 1024 / 进程权重 = 调度周期 * 1024 / 所有进程总权重 

​	 没错，虽然进程的权重不同，但是它们的 vruntime增长速度应该是一样的 ，与权重无关。 好，既然所有进程的vruntime增长速度宏观上看应该是同时推进的， 那么就可以用这个vruntime来选择运行的进程，谁的vruntime值较小就说明它以前占用cpu的时间较短， 受到了“不公平”对待，因此下一个运行进程就是它。这样既能公平选择进程，又能保证高优先级进程 获得较多的运行时间。 



具体实现时，CFS通过每个进程的**虚拟运行时间(vruntime)**来衡量哪个进程最值得被调度. CFS中的就绪队列是一棵以vruntime为键值的红黑树，虚拟时间越小的进程越靠近整个红黑树的最左端。因此，调度器每次选择位于红黑树最左端的那个进程，该进程的vruntime最小。

[CFS 调度器学习笔记 ](https://blog.csdn.net/melong100/article/details/6329201)

[ Linux CFS调度器之pick_next_task_fair选择下一个被调度的进程 ](https://blog.csdn.net/melong100/article/details/6329201)





